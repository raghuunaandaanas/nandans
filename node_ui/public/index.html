<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Superalgo Live Dashboard | B5 Factor Trading</title>
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --line: #243244;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --ok: #22c55e;
      --warn: #f59e0b;
      --down: #ef4444;
      --accent: #38bdf8;
      --level-near: #fde68a;
      --level-near-text: #1f2937;
      --level-pass: #334155;
      --danger: #dc2626;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 10% -20%, #23324b 0%, var(--bg) 55%);
      color: var(--text);
      font: 14px/1.4 "Segoe UI", system-ui, sans-serif;
    }
    .wrap { max-width: 2400px; margin: 0 auto; padding: 12px; }
    
    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px 15px;
      background: linear-gradient(180deg, #1e293b, #0f172a);
      border: 1px solid var(--line);
      border-radius: 10px;
    }
    .header h1 {
      margin: 0;
      font-size: 18px;
      color: var(--accent);
    }
    .ist-time {
      font-size: 24px;
      font-weight: 700;
      color: var(--ok);
      font-family: 'Courier New', monospace;
    }
    .ist-date {
      font-size: 12px;
      color: var(--muted);
    }
    
    /* Stats Grid */
    .top {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }
    .card {
      border: 1px solid var(--line);
      background: linear-gradient(180deg, #111827, #0e1626);
      border-radius: 10px;
      padding: 10px;
    }
    .card.danger {
      border-color: var(--danger);
      background: linear-gradient(180deg, #3f1818, #1f0a0a);
    }
    .card.warning {
      border-color: var(--warn);
      background: linear-gradient(180deg, #3f3018, #1f1a0a);
    }
    .card.success {
      border-color: var(--ok);
      background: linear-gradient(180deg, #183f1f, #0a1f0f);
    }
    .k { color: var(--muted); font-size: 11px; }
    .v { font-size: 15px; font-weight: 600; margin-top: 2px; }
    
    /* Broker Limit Meter */
    .limit-meter {
      display: flex;
      gap: 8px;
      margin-top: 5px;
    }
    .limit-bar {
      flex: 1;
      height: 6px;
      background: #1f2937;
      border-radius: 3px;
      overflow: hidden;
    }
    .limit-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    .limit-fill.green { background: var(--ok); }
    .limit-fill.yellow { background: var(--warn); }
    .limit-fill.red { background: var(--danger); }
    
    .ctrl {
      display: flex;
      gap: 8px;
      align-items: center;
      border: 1px solid var(--line);
      background: var(--card);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    input, select, button, a.nav {
      border: 1px solid var(--line);
      background: #0b1220;
      color: var(--text);
      border-radius: 8px;
      padding: 7px 10px;
      min-height: 34px;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
    }
    button { cursor: pointer; }
    button.export { background: #1e3a5f; }
    button.export:hover { background: #2d4a6f; }
    input[type="text"] { min-width: 200px; }
    table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid var(--line);
      background: #0b1220;
    }
    th, td {
      border-bottom: 1px solid #1f2937;
      padding: 6px;
      text-align: left;
      white-space: nowrap;
      font-size: 11px;
    }
    th {
      position: sticky;
      top: 0;
      background: #111827;
      color: #d1d5db;
      z-index: 2;
    }
    .ok { color: var(--ok); }
    .pending { color: var(--warn); }
    .trend-up { color: var(--ok); font-weight: 700; }
    .trend-down { color: var(--down); font-weight: 700; }
    .trend-side { color: var(--warn); font-weight: 700; }
    .near-up { color: #93c5fd; }
    .near-down { color: #fca5a5; }
    .jackpot { color: #fde047; font-weight: 700; }
    .table-wrap {
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow: auto;
      max-height: calc(100vh - 320px);
      background: #0b1220;
    }
    .meta { color: var(--muted); margin-left: auto; }
    .pill {
      display: inline-block;
      border: 1px solid var(--line);
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--accent);
    }
    .voice-on { color: var(--ok); }
    .voice-off { color: var(--down); }
    .level-near {
      background: var(--level-near);
      color: var(--level-near-text);
      font-weight: 700;
    }
    .level-pass {
      background: linear-gradient(180deg, #1e293b, #111827);
      color: #cbd5e1;
    }
    .prob-high { color: #86efac; font-weight: 700; }
    .prob-mid { color: #fcd34d; font-weight: 700; }
    .prob-low { color: #fca5a5; }
    
    /* Auto-close warning */
    .auto-close-warning {
      background: linear-gradient(90deg, #7c2d12, #92400e);
      border: 1px solid #ea580c;
      border-radius: 8px;
      padding: 8px 12px;
      margin-bottom: 10px;
      display: none;
    }
    .auto-close-warning.active {
      display: flex;
      align-items: center;
      gap: 10px;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Instrument badge */
    .inst-badge {
      display: inline-block;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .inst-equity { background: #1e3a5f; color: #7dd3fc; }
    .inst-option { background: #581c87; color: #d8b4fe; }
    .inst-future { background: #701a75; color: #f0abfc; }
    .inst-commodity { background: #7c2d12; color: #fdba74; }
    
    .factor-badge {
      display: inline-block;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .factor-micro { background: #065f46; color: #6ee7b7; }  /* 0.2611% - green */
    .factor-mini { background: #92400e; color: #fcd34d; }   /* 2.61% - amber */
    .factor-mega { background: #7f1d1d; color: #fca5a5; }   /* 26.11% - red */
    
    /* Traderscope Zone Badges */
    .zone-support { background: #1e3a5f; color: #7dd3fc; }
    .zone-resistance { background: #7c2d12; color: #fdba74; }
    .zone-accel { background: #14532d; color: #86efac; }
    .zone-neutral { background: #374151; color: #d1d5db; }
    
    /* Gamma Move Badge */
    .gamma-badge {
      display: inline-block;
      padding: 2px 6px;
      background: #dc2626;
      color: #fef2f2;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Header with IST Time -->
    <div class="header">
      <div>
        <h1>üìä Superalgo Live Dashboard | B5 Factor (Smart Selector)</h1>
        <div class="ist-date" id="istDate">-</div>
      </div>
      <div style="text-align: right;">
        <div class="ist-time" id="istTime">--:--:--</div>
        <div style="font-size: 11px; color: var(--muted);">IST (UTC+5:30) | Trading Zone: BU1-BU5 Only</div>
      </div>
    </div>

    <!-- Auto Close Warning -->
    <div class="auto-close-warning" id="autoCloseWarning">
      <span style="font-size: 20px;">‚ö†Ô∏è</span>
      <div>
        <strong>Market Closing Soon!</strong>
        <div style="font-size: 12px;">All NSE/BSE trades will auto-close at 3:28:30 PM IST. MCX at 11:30 PM IST.</div>
      </div>
    </div>

    <!-- Stats -->
    <div class="top" id="stats"></div>

    <!-- Broker Limit Meter -->
    <div class="card" style="margin-bottom: 10px;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span class="k">üìä Broker Limits Monitor</span>
        <span class="pill" id="brokerStatusBadge" style="background: #166534; color: #86efac;">SAFE</span>
      </div>
      <div style="margin-top: 8px;">
        <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px;">
          <span>Orders: <span id="ordersUsed">0</span> / <span id="ordersLimit">2000</span></span>
          <span id="ordersPct">0%</span>
        </div>
        <div class="limit-bar">
          <div class="limit-fill green" id="ordersBar" style="width: 0%"></div>
        </div>
      </div>
      <div style="margin-top: 8px;">
        <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px;">
          <span>Positions: <span id="positionsUsed">0</span> / <span id="positionsLimit">100</span></span>
          <span id="positionsPct">0%</span>
        </div>
        <div class="limit-bar">
          <div class="limit-fill green" id="positionsBar" style="width: 0%"></div>
        </div>
      </div>
      <div style="margin-top: 8px; font-size: 11px; color: var(--muted);" id="brokerUpdated">
        Updated: -
      </div>
    </div>

    <div class="ctrl">
      <span class="pill" id="snapDay">day:-</span>

      <label>Timeframe
        <select id="tf">
          <option value="1m">1m</option>
          <option value="5m" selected>5m</option>
          <option value="15m">15m</option>
        </select>
      </label>

      <label>Factor
        <select id="factor">
          <option value="smart" selected>üß† Smart (Auto)</option>
          <option value="micro">micro 0.2611%</option>
          <option value="mini">mini 2.61%</option>
          <option value="mega">mega 26.11%</option>
        </select>
      </label>

      <input id="search" type="text" placeholder="Search symbol or tsym" />
      <label><input id="completeOnly" type="checkbox" /> Complete only</label>
      <label><input id="triggerOnly" type="checkbox" checked /> Only trend ranges</label>
      <label><input id="voiceOn" type="checkbox" checked /> Voice</label>
      <label>Voice
        <select id="voicePreset">
          <option value="indian_male" selected>Indian Male</option>
          <option value="indian_female">Indian Female</option>
          <option value="english_male">English Male</option>
          <option value="english_female">English Female</option>
          <option value="auto">Auto</option>
        </select>
      </label>
      <label>VoiceGap(s) <input id="voiceGap" type="number" value="3" min="1" max="30" style="width:75px"/></label>
      <label>Fresh(s) <input id="freshSec" type="number" value="20" min="5" max="120" style="width:75px"/></label>
      <label>Bulletin(s) <input id="bulletinSec" type="number" value="60" min="20" max="600" style="width:80px"/></label>
      <label>Limit <input id="limit" type="number" value="5000" min="1" max="50000" style="width:85px"/></label>
      <label>Refresh(ms) <input id="refreshMs" type="number" value="2000" min="500" max="10000" style="width:100px"/></label>
      <button id="apply">Apply</button>
      <button id="voiceTest">Voice test</button>
      <button class="export" id="exportCsv">Export CSV</button>
      <a class="nav" href="/trades.html" target="_blank">Trade Monitor</a>
      <span class="pill" id="voiceStatus">voice:-</span>
      <span class="meta" id="meta">-</span>
    </div>

    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Symbol</th>
            <th>TSym</th>
            <th>Type</th>
            <th>Factor</th>
            <th>LTP</th>
            <th>Volume</th>
            <th>VolŒî</th>
            <th>Trend</th>
            <th>Near</th>
            <th>Confirm</th>
            <th>Prob</th>
            <th>Jackpot</th>
            <th>Close(TF)</th>
            <th>Points</th>
            <th>BE5</th>
            <th>BE1</th>
            <th>BU1</th>
            <th>BU3</th>
            <th>BU5</th>
            <th>RR(BU5)</th>
            <th>InRange</th>
            <th>Digit</th>
            <th>Position</th>
            <th>Zone</th>
            <th>Gamma</th>
            <th>Updated(IST)</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
  </div>

  <script>
    const statsEl = document.getElementById('stats');
    const rowsEl = document.getElementById('rows');
    const metaEl = document.getElementById('meta');
    const snapDayEl = document.getElementById('snapDay');
    const voiceStatusEl = document.getElementById('voiceStatus');
    const istTimeEl = document.getElementById('istTime');
    const istDateEl = document.getElementById('istDate');
    const autoCloseWarningEl = document.getElementById('autoCloseWarning');

    const tfEl = document.getElementById('tf');
    const factorEl = document.getElementById('factor');
    const searchEl = document.getElementById('search');
    const completeOnlyEl = document.getElementById('completeOnly');
    const triggerOnlyEl = document.getElementById('triggerOnly');
    const voiceOnEl = document.getElementById('voiceOn');
    const voicePresetEl = document.getElementById('voicePreset');
    const voiceGapEl = document.getElementById('voiceGap');
    const freshSecEl = document.getElementById('freshSec');
    const bulletinSecEl = document.getElementById('bulletinSec');
    const limitEl = document.getElementById('limit');
    const refreshMsEl = document.getElementById('refreshMs');
    const applyEl = document.getElementById('apply');
    const voiceTestEl = document.getElementById('voiceTest');
    const exportCsvEl = document.getElementById('exportCsv');

    let timer = null;
    const rowOrder = new Map();
    let rowSeq = 0;

    const voiceState = {
      queue: [],
      speaking: false,
      announcedAt: new Map(),
      symbolPulse: new Map(),
      openTradeSeen: new Set(),
      closedTradeSeen: new Set(),
      lastTradePollMs: 0,
      lastBulletinMs: 0,
      lastNoTradesIntro: 0,
      maxQueue: 40,
      voices: [],
      selectedVoice: null,
    };

    function f2(v) {
      if (v === null || v === undefined || v === '') return '-';
      const n = Number(v);
      return Number.isFinite(n) ? n.toFixed(2) : String(v);
    }

    function f4(v) {
      if (v === null || v === undefined || v === '') return '-';
      const n = Number(v);
      return Number.isFinite(n) ? n.toFixed(4) : String(v);
    }

    function i0(v) {
      const n = Number(v);
      return Number.isFinite(n) ? Math.round(n).toString() : '-';
    }

    function safe(obj, path, d = '-') {
      let cur = obj;
      for (const p of path) {
        if (!cur || typeof cur !== 'object' || !(p in cur)) return d;
        cur = cur[p];
      }
      return cur ?? d;
    }

    function toNum(v, d = null) {
      if (v === null || v === undefined || v === '') return d;
      const n = Number(v);
      return Number.isFinite(n) ? n : d;
    }

    function toMs(v) {
      const ms = Date.parse(String(v || ''));
      return Number.isFinite(ms) ? ms : null;
    }
    
    function formatISTTime() {
      const now = new Date();
      return now.toLocaleTimeString('en-IN', { 
        timeZone: 'Asia/Kolkata',
        hour12: false,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    }
    
    function formatISTDate() {
      const now = new Date();
      return now.toLocaleDateString('en-IN', { 
        timeZone: 'Asia/Kolkata',
        weekday: 'short',
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }
    
    function checkAutoClose(status) {
      const marketTime = status?.market_time || {};
      const nseClose = marketTime.auto_close_nse_bse;
      const mcxClose = marketTime.auto_close_mcx;
      
      if (nseClose || mcxClose) {
        autoCloseWarningEl.classList.add('active');
      } else {
        autoCloseWarningEl.classList.remove('active');
      }
    }
    
    function updateBrokerLimits(limits) {
      if (!limits) return;
      
      document.getElementById('ordersUsed').textContent = limits.orders_placed || 0;
      document.getElementById('ordersLimit').textContent = limits.orders_limit || 2000;
      document.getElementById('ordersPct').textContent = (limits.orders_pct_used || 0) + '%';
      document.getElementById('positionsUsed').textContent = limits.open_positions || 0;
      document.getElementById('positionsLimit').textContent = limits.positions_limit || 100;
      document.getElementById('positionsPct').textContent = (limits.positions_pct_used || 0) + '%';
      document.getElementById('brokerUpdated').textContent = 'Updated: ' + (limits.updated_at || '-');
      
      const ordersBar = document.getElementById('ordersBar');
      const positionsBar = document.getElementById('positionsBar');
      const badge = document.getElementById('brokerStatusBadge');
      
      ordersBar.style.width = Math.min(100, parseFloat(limits.orders_pct_used || 0)) + '%';
      positionsBar.style.width = Math.min(100, parseFloat(limits.positions_pct_used || 0)) + '%';
      
      const color = limits.status_color || 'green';
      ordersBar.className = `limit-fill ${color}`;
      positionsBar.className = `limit-fill ${color}`;
      
      if (color === 'green') {
        badge.textContent = 'SAFE';
        badge.style.background = '#166534';
        badge.style.color = '#86efac';
      } else if (color === 'yellow') {
        badge.textContent = 'WARNING';
        badge.style.background = '#854d0e';
        badge.style.color = '#fde047';
      } else {
        badge.textContent = 'DANGER';
        badge.style.background = '#7f1d1d';
        badge.style.color = '#fca5a5';
      }
    }

    // Make company names readable for voice
    function humanSymbol(r) {
      const ts = String(r.tsym || '').trim();
      if (!ts || /^\d+$/.test(ts)) return String(r.symbol || '');
      
      // Extract company name and format for speech
      let name = ts;
      
      // Remove date part (20FEB26, 24FEB26, etc)
      name = name.replace(/\d{2}[A-Z]{3}\d{2,4}/, '');
      
      // Remove strike price and option type for voice
      name = name.replace(/\d+(CE|PE)$/i, '');
      name = name.replace(/FUT$/i, '');
      
      // Clean up and return
      name = name.replace(/([a-z])([A-Z])/g, '$1 $2'); // Split camelCase
      name = name.replace(/([A-Z]{2,})([A-Z][a-z])/g, '$1 $2'); // Split ALLCAPS followed by Title
      
      // Specific company pronunciations
      const companyMap = {
        'WIPRO': 'Wipro',
        'RELIANCE': 'Reliance',
        'TCS': 'T C S',
        'INFY': 'Infosys',
        'HDFC': 'H D F C',
        'ICICI': 'I C I C I',
        'SBIN': 'S B I',
        'AXIS': 'Axis',
        'KOTAK': 'Kotak',
        'MARUTI': 'Maruti',
        'TATA': 'Tata',
        'BAJAJ': 'Bajaj',
        'SUNPHARMA': 'Sun Pharma',
        'DRREDDY': 'D R Reddy',
        'CIPLA': 'Cipla',
        'ITC': 'I T C',
        'HCL': 'H C L',
        'TECHM': 'Tech Mahindra',
        'ONGC': 'O N G C',
        'NTPC': 'N T P C',
        'POWERGRID': 'Power Grid',
        'COAL': 'Coal',
        'HINDALCO': 'Hindalco',
        'VEDL': 'Vedanta',
        'JSW': 'J S W',
        'ADANI': 'Adani',
        'TATAMOTORS': 'Tata Motors',
        'M&M': 'M and M',
        'HEROMOTOCO': 'Hero Moto',
        'EICHERMOT': 'Eicher Motors',
        'TVSMOTOR': 'T V S Motor',
        'BAJAJAUTO': 'Bajaj Auto',
        'GODREJCP': 'Godrej Consumer',
        'DABUR': 'Dabur',
        'NESTLE': 'Nestle',
        'HINDUNILVR': 'Hindustan Unilever',
        'BRITANNIA': 'Britannia',
        'TITAN': 'Titan',
        'ASIANPAINT': 'Asian Paints',
        'BERGEPAINT': 'Berger Paints',
        'ULTRACEMCO': 'UltraTech Cement',
        'SHREECEM': 'Shree Cement',
        'GRASIM': 'Grasim',
        'AMBUJACEM': 'Ambuja Cement',
        'ACC': 'A C C',
        'DLF': 'D L F',
        'OBEROIRLTY': 'Oberoi Realty',
        'PHOENIXLTD': 'Phoenix Limited',
        'SBILIFE': 'S B I Life',
        'HDFCLIFE': 'H D F C Life',
        'ICICIPRULI': 'I C I C I Pru Life',
        'BAJAJFINSV': 'Bajaj Finserv',
        'BAJFINANCE': 'Bajaj Finance',
        'CHOLAFIN': 'Chola Finance',
        'MUTHOOTFIN': 'Muthoot Finance',
        'PFC': 'P F C',
        'RECLTD': 'R E C Limited',
        'LICHSGFIN': 'L I C Housing',
        'CANFINHOME': 'Can Fin Homes',
        'NATURALGAS': 'Natural Gas',
        'SILVER': 'Silver',
        'GOLD': 'Gold',
        'CRUDEOIL': 'Crude Oil',
      };
      
      // Check direct match
      for (const [code, pronounce] of Object.entries(companyMap)) {
        if (name.includes(code)) {
          return pronounce;
        }
      }
      
      return name.trim() || ts;
    }

    function instrumentType(exchange, tsym) {
      const ex = String(exchange || '').toUpperCase();
      const t = String(tsym || '').toUpperCase();
      if (ex === 'MCX') return 'COMMODITY';
      if (ex === 'NFO' || ex === 'BFO') {
        if (/(CE|PE)/.test(t) || /[CP]\d{2,6}$/.test(t)) return 'OPTION';
        if (/FUT/.test(t) || /\dF$/.test(t) || /\d{2}[A-Z]{3}\d{2}F/.test(t)) return 'FUTURE';
        return 'DERIVATIVE';
      }
      return 'EQUITY';
    }
    
    function instBadgeClass(type) {
      return {
        'EQUITY': 'inst-equity',
        'OPTION': 'inst-option',
        'FUTURE': 'inst-future',
        'COMMODITY': 'inst-commodity',
        'DERIVATIVE': 'inst-future'
      }[type] || 'inst-equity';
    }

    function levelClass(levelName, levelVal, ltp, points, nearName) {
      const p = Math.abs(toNum(points, 0));
      const tol = Math.max(p * 0.12, Math.abs(toNum(ltp, 0)) * 0.00035);
      const diff = Math.abs(toNum(ltp, 0) - toNum(levelVal, 0));
      const near = nearName === levelName || diff <= tol;
      if (near) return 'level-near';
      if (levelName.startsWith('BU') && toNum(ltp, -1e15) >= toNum(levelVal, 1e15)) return 'level-pass';
      if (levelName.startsWith('BE') && toNum(ltp, 1e15) <= toNum(levelVal, -1e15)) return 'level-pass';
      return '';
    }

    function probClass(score) {
      const n = toNum(score, 0);
      if (n >= 75) return 'prob-high';
      if (n >= 50) return 'prob-mid';
      return 'prob-low';
    }

    function statCards(data) {
      const s = data.status || {};
      const t = s.trade || {};
      const h = s.past_data_download || {};
      const ws = s.websocket || {};
      const login = s.login || {};
      const stg = s.storage || {};
      const hs = s.history_store || {};

      const cards = [
        ['Total Symbols', safe(data, ['stats', 'total_symbols'], 0)],
        ['Today Complete', safe(data, ['stats', 'today_complete'], 0)],
        ['Today Pending', safe(data, ['stats', 'today_pending'], 0)],
        ['Backfill', `${safe(h, ['done_symbols'], 0)}/${safe(h, ['total_symbols'], 0)} (${f2(safe(h, ['progress_pct'], 0))}%)`],
        ['Login', login.ok ? 'OK' : 'NO'],
        ['WebSocket', ws.open ? 'OPEN' : 'DOWN'],
        ['Ticks Stored', safe(hs, ['ticks_stored'], 0)],
        ['Trade Engine', `${safe(t, ['mode'], '-')}/${safe(t, ['engine_state'], '-')}`],
        ['Trades O/C', `${safe(t, ['open_trades'], 0)} / ${safe(t, ['closed_trades'], 0)}`],
        ['Net PnL', '‚Çπ' + f2(safe(t, ['net_pnl'], 0))],
        ['Max Drawdown', '‚Çπ' + f2(safe(t, ['max_drawdown'], 0))],
        ['DB MB', f2(safe(stg, ['db_file_mb'], 0))],
      ];

      statsEl.innerHTML = cards.map(([k, v]) => `
        <div class="card"><div class="k">${k}</div><div class="v">${v}</div></div>
      `).join('');
      
      // Update broker limits
      updateBrokerLimits(s.broker_limits);
      
      // Check auto-close warning
      checkAutoClose(s);
    }

    function stableRows(rows) {
      for (const r of rows) {
        const key = String(r.symbol || '');
        if (!rowOrder.has(key)) {
          rowOrder.set(key, rowSeq);
          rowSeq += 1;
        }
      }
      return [...rows].sort((a, b) => {
        const ka = rowOrder.get(String(a.symbol || '')) ?? 1e12;
        const kb = rowOrder.get(String(b.symbol || '')) ?? 1e12;
        if (ka !== kb) return ka - kb;
        return String(a.symbol || '').localeCompare(String(b.symbol || ''));
      });
    }

    function renderRows(rows) {
      const out = stableRows(rows || []);
      rowsEl.innerHTML = out.map(r => {
        const trend = String(r.trend || 'SIDEWAYS');
        const trendClass = trend === 'UP' ? 'trend-up' : trend === 'DOWN' ? 'trend-down' : 'trend-side';
        const near = String(r.near_name || '-');
        const nearClass = near.startsWith('BU') ? 'near-up' : (near.startsWith('BE') ? 'near-down' : '');
        const jackpot = !!r.jackpot_be5_reversal || !!r.jackpot_long;
        const type = instrumentType(r.exchange, r.tsym);

        const be1c = levelClass('BE1', r.be1, r.ltp, r.points, near);
        const be5c = levelClass('BE5', r.be5, r.ltp, r.points, near);
        const bu1c = levelClass('BU1', r.bu1, r.ltp, r.points, near);
        const bu3c = levelClass('BU3', r.bu3, r.ltp, r.points, near);
        const bu5c = levelClass('BU5', r.bu5, r.ltp, r.points, near);

        const factorBadge = r.selected_factor ? `<span class="factor-badge factor-${r.selected_factor}">${r.selected_factor.toUpperCase()}</span>` : '-';
        
        // Traderscope rendering
        const digit = r.selected_digit ?? '-';
        const position = r.position_pct ?? '-';
        const zoneName = r.zone_name ?? '-';
        const zoneType = r.zone_type ?? '-';
        const zoneClass = zoneType === 'support' ? 'zone-support' : 
                         zoneType === 'resistance' ? 'zone-resistance' : 
                         zoneType === 'acceleration' ? 'zone-accel' : 'zone-neutral';
        const gammaBadge = r.gamma_move?.detected ? 
          `<span class="gamma-badge">üöÄ ${r.gamma_move.score}</span>` : '-';
        
        return `
          <tr>
            <td>${r.symbol ?? ''}</td>
            <td>${r.tsym ?? ''}</td>
            <td><span class="inst-badge ${instBadgeClass(type)}">${type}</span></td>
            <td>${factorBadge}</td>
            <td>${f2(r.ltp)}</td>
            <td>${i0(r.volume)}</td>
            <td>${i0(r.volume_delta)}</td>
            <td class="${trendClass}">${trend}</td>
            <td class="${nearClass}">${near} (${f2(r.near_diff)})</td>
            <td>${r.confirmation ?? 0}</td>
            <td class="${probClass(r.probability_score)}">${i0(r.probability_score)}</td>
            <td class="${jackpot ? 'jackpot' : ''}">${jackpot ? 'JACKPOT' : '-'}</td>
            <td>${f2(r.close)}</td>
            <td>${f4(r.points)}</td>
            <td class="${be5c}">${f2(r.be5)}</td>
            <td class="${be1c}">${f2(r.be1)}</td>
            <td class="${bu1c}">${f2(r.bu1)}</td>
            <td class="${bu3c}">${f2(r.bu3)}</td>
            <td class="${bu5c}">${f2(r.bu5)}</td>
            <td>${f2(r.rr_to_bu5)}</td>
            <td class="${r.in_range_up ? 'ok' : 'pending'}">${r.in_range_up ? 'YES' : 'NO'}</td>
            <td>${digit}</td>
            <td>${position}%</td>
            <td class="${zoneClass}">${zoneName}</td>
            <td>${gammaBadge}</td>
            <td>${r.ist_time || formatISTTime()}</td>
          </tr>
        `;
      }).join('');
    }

    function voiceSupported() {
      return typeof window !== 'undefined' && 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    }

    function voiceGapMs() {
      return Math.max(1000, Math.min(30000, Number(voiceGapEl.value || 3) * 1000));
    }

    function freshnessMs() {
      return Math.max(5000, Math.min(120000, Number(freshSecEl.value || 20) * 1000));
    }

    function bulletinMs() {
      return Math.max(20000, Math.min(600000, Number(bulletinSecEl.value || 60) * 1000));
    }

    function updateVoiceStatus(text, on = null) {
      const enabled = on === null ? (voiceOnEl.checked && voiceSupported()) : !!on;
      voiceStatusEl.textContent = text;
      voiceStatusEl.className = `pill ${enabled ? 'voice-on' : 'voice-off'}`;
    }

    function clearVoiceQueue() {
      voiceState.queue.length = 0;
      voiceState.speaking = false;
      try {
        if (voiceSupported()) window.speechSynthesis.cancel();
      } catch {}
    }

    function voiceMatch(preset, v) {
      const name = String(v.name || '').toLowerCase();
      const lang = String(v.lang || '').toLowerCase();
      // Indian languages
      const isIn = lang.includes('en-in') || lang.includes('hi-in') || lang.includes('bn-in') || lang.includes('ta-in') || lang.includes('te-in') || lang.includes('mr-in') || lang.includes('gu-in');
      // Strict male/female detection
      const maleHint = /\bmale\b|\bman\b|rahul|ravi|vivek|hemant|aditya|aarav|arjun|karan|raj/.test(name);
      const femaleHint = /\bfemale\b|\bwoman\b|sangeeta|karen|zira|susan|raveena|siri|lisa|mary/.test(name);
      const isEn = lang.startsWith('en');
      
      if (preset === 'indian_male') return isIn && maleHint;
      if (preset === 'indian_female') return isIn && femaleHint;
      if (preset === 'english_male') return isEn && maleHint && !isIn;
      if (preset === 'english_female') return isEn && femaleHint && !isIn;
      return true;
    }

    function pickVoice() {
      if (!voiceSupported()) return null;
      const voices = window.speechSynthesis.getVoices() || [];
      voiceState.voices = voices;
      if (!voices.length) return null;
      const preset = String(voicePresetEl.value || 'indian_male');

      let selected = null;
      
      // Try exact match first
      selected = voices.find((v) => voiceMatch(preset, v));
      
      // Fallback: any Indian voice for indian presets
      if (!selected && preset.startsWith('indian')) {
        selected = voices.find((v) => /en-in|hi-in/i.test(String(v.lang || '')));
      }
      
      // Fallback: any English voice
      if (!selected) {
        selected = voices.find((v) => /^en/i.test(String(v.lang || '')));
      }
      
      // Last resort: first available
      if (!selected) selected = voices[0];
      
      voiceState.selectedVoice = selected;
      console.log('Selected voice:', selected?.name, 'lang:', selected?.lang, 'for preset:', preset);
      return selected;
    }

    // Phonetic spellings - make words sound natural
    const PHONETIC_MAP = {
      // Common words
      'either': 'ee-ther',
      'neither': 'nee-ther',
      // Option types - say as words not letters
      ' CE': ' Call',
      ' PE': ' Put',
      ' FUT': ' Future',
      // Indices
      'NIFTY': 'Nifty',
      'BANKNIFTY': 'Bank Nifty',
      'FINNIFTY': 'Fin Nifty',
      'SENSEX': 'Sensex',
      'BANKEX': 'Bankex',
      // Exchanges
      'MCX': 'MCX',
      'NSE': 'NSE',
      'BSE': 'BSE',
      'NFO': 'NFO',
      'BFO': 'BFO',
      // Commodities
      'SILVERMIC': 'Silver Micro',
      'GOLDMIC': 'Gold Micro',
      'GOLDTEN': 'Gold Tenth',
      'CRUDEOIL': 'Crude Oil',
      'NATURALGAS': 'Natural Gas',
      'COTTONOIL': 'Cotton Oil',
      'ALUMINIUM': 'Aluminium',
      'COPPER': 'Copper',
      'ZINC': 'Zinc',
      'NICKEL': 'Nickel',
      'LEAD': 'Lead',
      // Price levels
      'BU1': 'Buy One',
      'BU2': 'Buy Two',
      'BU3': 'Buy Three',
      'BU4': 'Buy Four',
      'BU5': 'Buy Five',
      'BE1': 'Below One',
      'BE2': 'Below Two',
      'BE3': 'Below Three',
      'BE4': 'Below Four',
      'BE5': 'Below Five',
    };
    
    function phoneticFix(text) {
      let result = text;
      // Replace words with natural pronunciations
      for (const [word, phonetic] of Object.entries(PHONETIC_MAP)) {
        result = result.replace(new RegExp(word, 'g'), phonetic);
      }
      // Clean up multiple spaces
      result = result.replace(/\s+/g, ' ').trim();
      return result;
    }

    function speakText(text, onend, onerror, priority = 5) {
      // Fix pronunciation
      const fixedText = phoneticFix(text);
      const utter = new SpeechSynthesisUtterance(fixedText);
      const selected = voiceState.selectedVoice || pickVoice();
      if (selected) utter.voice = selected;
      utter.lang = selected?.lang || 'en-IN';
      // Indian news anchor style
      utter.rate = 0.9;
      utter.pitch = 1.0;
      utter.volume = 1.0;
      utter.onend = onend;
      utter.onerror = onerror;
      
      // Priority 1 = interrupt current speech (for trades)
      if (priority === 1 && voiceState.speaking) {
        window.speechSynthesis.cancel();
        voiceState.speaking = false;
      }
      
      window.speechSynthesis.speak(utter);
    }

    // For immediate trade announcements - bypass queue
    function speakImmediate(text, priority = 1) {
      if (!voiceOnEl.checked || !voiceSupported()) return;
      
      // Cancel any current speech for priority 1 (trade alerts)
      if (priority === 1) {
        window.speechSynthesis.cancel();
        voiceState.speaking = false;
      }
      
      voiceState.speaking = true;
      speakText(text, 
        () => { voiceState.speaking = false; },
        () => { voiceState.speaking = false; },
        priority
      );
    }

    function enqueueVoice(key, text, priority = 5, cooldownMs = 45000) {
      if (!voiceOnEl.checked || !voiceSupported()) return;
      
      // Priority 1 = immediate (trades), don't queue
      if (priority === 1) {
        speakImmediate(text, priority);
        return;
      }
      
      const now = Date.now();
      const last = voiceState.announcedAt.get(key) || 0;
      if (now - last < cooldownMs) return;
      if (voiceState.queue.find((q) => q.key === key)) return;

      voiceState.announcedAt.set(key, now);
      voiceState.queue.push({ key, text, priority, ts: now });
      voiceState.queue.sort((a, b) => a.priority - b.priority || a.ts - b.ts);
      if (voiceState.queue.length > voiceState.maxQueue) voiceState.queue.length = voiceState.maxQueue;
      pumpVoiceQueue();
    }

    function pumpVoiceQueue() {
      if (!voiceOnEl.checked || !voiceSupported()) {
        clearVoiceQueue();
        updateVoiceStatus('voice:off', false);
        return;
      }

      if (voiceState.speaking) {
        updateVoiceStatus(`voice:on q:${voiceState.queue.length}`, true);
        return;
      }

      const next = voiceState.queue.shift();
      if (!next) {
        const vn = voiceState.selectedVoice ? `${voiceState.selectedVoice.name}` : 'idle';
        updateVoiceStatus(`voice:on ${vn}`, true);
        return;
      }

      voiceState.speaking = true;
      updateVoiceStatus(`voice:on speaking q:${voiceState.queue.length}`, true);
      speakText(
        next.text,
        () => {
          voiceState.speaking = false;
          setTimeout(pumpVoiceQueue, voiceGapMs());
        },
        () => {
          voiceState.speaking = false;
          setTimeout(pumpVoiceQueue, 600);
        },
        next.priority
      );
    }

    function isFresh(updatedAt) {
      const ms = toMs(updatedAt);
      if (!ms) return true;
      return (Date.now() - ms) <= freshnessMs();
    }

    function rememberPulse(symbol, data) {
      voiceState.symbolPulse.set(symbol, data);
    }

    function getPulse(symbol) {
      return voiceState.symbolPulse.get(symbol) || {};
    }

    function buildSignalCandidates(rows, config) {
      const out = [];
      const now = Date.now();
      const lookbackMs = Math.max(120000, Number(config?.jackpot_touch_lookback_sec || 1800) * 1000);
      const jackpotMinConf = Math.max(3, Number(config?.jackpot_min_confirmation || 3));
      const jackpotMinRR = Math.max(2.0, Number(config?.jackpot_min_rr || 2.2));
      const minProb = Math.max(60, Number(config?.min_probability_score || 70));

      for (const r of rows || []) {
        if (!isFresh(r.updated_at)) continue;

        const symbol = String(r.symbol || '');
        if (!symbol) continue;

        const ltp = toNum(r.ltp);
        const bu1 = toNum(r.bu1);
        const bu5 = toNum(r.bu5);
        const be5 = toNum(r.be5);
        const points = Math.abs(toNum(r.points, 0));
        const vol = Math.max(0, toNum(r.volume, 0));
        const conf = toNum(r.confirmation, 0);
        const trend = String(r.trend || 'SIDEWAYS');
        const prob = toNum(r.probability_score, 0);

        if ([ltp, bu1, bu5, be5].some((v) => v === null)) continue;

        const pulsePrev = getPulse(symbol);
        const prevLtp = toNum(pulsePrev.ltp);
        const prevVol = toNum(pulsePrev.volume, vol);
        const prevVolDelta = toNum(pulsePrev.volDelta, 0);

        const volDelta = Math.max(0, vol - prevVol);
        const volAccel = prevVolDelta > 0 ? (volDelta / prevVolDelta) : (volDelta > 0 ? 1 : 0);

        let be5TouchAt = toNum(pulsePrev.be5TouchAt, 0);
        let be5Low = toNum(pulsePrev.be5Low, null);
        if (ltp <= be5) {
          be5TouchAt = now;
          be5Low = be5Low === null ? ltp : Math.min(be5Low, ltp);
        }

        const be5Recent = be5TouchAt > 0 && (now - be5TouchAt) <= lookbackMs;
        if (!be5Recent) {
          be5TouchAt = 0;
          be5Low = null;
        }

        rememberPulse(symbol, { ltp, volume: vol, volDelta, be5TouchAt, be5Low });

        const reward = Math.max(0, bu5 - ltp);
        const risk = Math.max(0.0001, ltp - bu1);
        const rr = reward / risk;
        const type = instrumentType(r.exchange, r.tsym);
        const symbolName = `${type} ${humanSymbol(r)}`;

        const nearBu1 = Math.abs(ltp - bu1) <= Math.max(points * 0.15, Math.abs(ltp) * 0.00035);
        const crossedBu1 = prevLtp !== null && prevLtp < bu1 && ltp >= bu1;

        if (!r.spike_flag && trend !== 'DOWN' && ltp < bu1 && nearBu1 && volAccel >= 1.2 && conf >= 2 && prob >= (minProb - 10)) {
          out.push({
            key: `setup:${symbol}`,
            priority: 4,
            cooldownMs: 90000,
            score: 70,
            text: `${symbolName}. Setup near Buy One level ${bu1.toFixed(2)}. Rising volume. Wait for confirmation.`,
          });
        }

        if (!r.spike_flag && r.in_range_up && r.jackpot_be5_reversal && be5Recent && prob >= minProb && conf >= jackpotMinConf && rr >= jackpotMinRR && (crossedBu1 || nearBu1)) {
          out.push({
            key: `jackpot:${symbol}`,
            priority: 2,
            cooldownMs: 180000,
            score: 100,
            text: `Jackpot Alert. ${symbolName}. High probability reversal. Entry between Buy One ${bu1.toFixed(2)} and Buy Five ${bu5.toFixed(2)}. Risk reward ${rr.toFixed(1)} to 1.`,
          });
        }

        if (trend === 'UP' && ltp >= (bu5 * 0.997) && prob >= minProb) {
          out.push({
            key: `exit:${symbol}`,
            priority: 3,
            cooldownMs: 90000,
            score: 90,
            text: `${symbolName}. Approaching target Buy Five at ${bu5.toFixed(2)}. Book profits or move stop loss.`,
          });
        }
      }

      out.sort((a, b) => b.score - a.score || a.priority - b.priority);
      return out.slice(0, 4);
    }

    function buildBulletin(rows) {
      const topVol = [];
      const topGain = [];
      let up = 0, down = 0, side = 0, hitBu1 = 0, hitBu3 = 0, hitBu5 = 0;

      function addTop(arr, item, metric) {
        if (item[metric] === null || item[metric] === undefined) return;
        arr.push(item);
        arr.sort((a, b) => Number(b[metric]) - Number(a[metric]));
        if (arr.length > 5) arr.length = 5;
      }

      for (const r of rows || []) {
        const ltp = toNum(r.ltp);
        const close = toNum(r.close);
        const volume = toNum(r.volume);
        if (ltp === null) continue;

        const trend = String(r.trend || 'SIDEWAYS');
        if (trend === 'UP') up += 1;
        else if (trend === 'DOWN') down += 1;
        else side += 1;

        if (r.above_bu1) hitBu1 += 1;
        if (toNum(r.ltp) >= toNum(r.bu3, 1e15)) hitBu3 += 1;
        if (toNum(r.ltp) >= toNum(r.bu5, 1e15)) hitBu5 += 1;

        const type = instrumentType(r.exchange, r.tsym);
        const item = {
          name: `${type} ${humanSymbol(r)}`,
          volume,
          gain: close && close > 0 ? ((ltp - close) / close) * 100 : null,
        };
        if (volume !== null) addTop(topVol, item, 'volume');
        if (item.gain !== null) addTop(topGain, item, 'gain');
      }

      if (!topVol.length && !topGain.length) return null;

      const vTxt = topVol.map((x) => `${x.name} volume ${i0(x.volume)}`).join(', ');
      const gTxt = topGain.map((x) => `${x.name} up ${x.gain.toFixed(2)} percent`).join(', ');

      return `Namaskar. Superalgo market update. Top volume: ${vTxt || 'not available'}. Top gainers: ${gTxt || 'not available'}. Trend: ${up} up, ${down} down, ${side} sideways. ${hitBu1} above Buy One, ${hitBu3} above Buy Three, ${hitBu5} above Buy Five. Trade Buy One to Buy Five range for best setups.`;
    }
    
    function buildNoTradesIntro() {
      const now = Date.now();
      if ((now - voiceState.lastNoTradesIntro) < 300000) return null;
      
      voiceState.lastNoTradesIntro = now;
      
      const intros = [
        `Superalgo monitoring. Waiting for Buy One to Buy Five setups.`,
        `Namaskar. Superalgo active. Scanning for reversal candidates.`,
        `Market watch on. Trading Buy One to Buy Five range only.`,
      ];
      
      return intros[Math.floor(Math.random() * intros.length)];
    }

    function processVoiceFromRows(rows, config) {
      if (!voiceOnEl.checked || !voiceSupported()) return;
      
      // If no trades and no signals, do a periodic intro
      const hasActiveSignals = rows.some(r => r.in_range_up && r.probability_score >= 70);
      if (!hasActiveSignals) {
        const intro = buildNoTradesIntro();
        if (intro) {
          enqueueVoice('intro:' + Date.now(), intro, 5, 300000);
        }
      }
      
      const candidates = buildSignalCandidates(rows, config);
      for (const c of candidates) {
        enqueueVoice(c.key, c.text, c.priority, c.cooldownMs);
      }
    }

    async function processVoiceFromTrades() {
      if (!voiceOnEl.checked || !voiceSupported()) return;
      const now = Date.now();
      if ((now - voiceState.lastTradePollMs) < 3000) return;
      voiceState.lastTradePollMs = now;

      try {
        const res = await fetch('/api/trades?open_limit=40&closed_limit=40');
        const data = await res.json();
        const fresh = freshnessMs();

        for (const t of (data.open_trades || [])) {
          const id = String(t.id || '');
          if (!id || voiceState.openTradeSeen.has(id)) continue;
          const ts = toMs(t.entry_ts);
          if (ts && (Date.now() - ts) > fresh) continue;
          voiceState.openTradeSeen.add(id);
          const type = instrumentType(t.exchange, t.tsym || t.display_symbol);
          const sym = humanSymbol({tsym: t.display_symbol || t.tsym || t.symbol});
          const msg = `Trade Alert. ${sym} ${type}. Entry at ${t.entry_ltp?.toFixed(2)}. Stop ${t.sl_price?.toFixed(2)}. Target ${t.tp_price?.toFixed(2)}.`;
          // Priority 1 = immediate, interrupts current speech
          enqueueVoice(`trade-open:${id}`, msg, 1, 15000);
        }

        for (const t of (data.recent_closed || [])) {
          const id = String(t.id || '');
          if (!id || voiceState.closedTradeSeen.has(id)) continue;
          const ts = toMs(t.exit_ts);
          if (ts && (Date.now() - ts) > fresh) continue;
          voiceState.closedTradeSeen.add(id);
          const type = instrumentType(t.exchange, t.tsym || t.display_symbol);
          const sym = humanSymbol({tsym: t.display_symbol || t.tsym || t.symbol});
          const netPnl = toNum(t.net_pnl, toNum(t.pnl, 0));
          const pnlText = netPnl >= 0 ? `profit ${netPnl.toFixed(2)}` : `loss ${Math.abs(netPnl).toFixed(2)}`;
          const msg = `Trade Closed. ${sym}. ${pnlText} rupees.`;
          // Priority 1 = immediate
          enqueueVoice(`trade-close:${id}`, msg, 1, 10000);
        }
      } catch {
      }
    }

    function maybeBulletin(rows) {
      if (!voiceOnEl.checked || !voiceSupported()) return;
      if (voiceState.speaking || voiceState.queue.length > 0) return;
      const now = Date.now();
      if ((now - voiceState.lastBulletinMs) < bulletinMs()) return;

      const text = buildBulletin(rows);
      if (!text) return;

      voiceState.lastBulletinMs = now;
      enqueueVoice(`bulletin:${Math.floor(now / bulletinMs())}`, text, 5, bulletinMs());
    }
    
    async function exportTrades() {
      try {
        const res = await fetch('/api/export?format=csv');
        const data = await res.json();
        if (data.success) {
          alert(`Export successful!\nFilename: ${data.filename}\nTrades: ${data.count}\nTime: ${data.ist_time}`);
          window.open(data.download_url, '_blank');
        } else {
          alert('Export failed: ' + (data.error || 'Unknown error'));
        }
      } catch (e) {
        alert('Export error: ' + e.message);
      }
    }

    async function refresh() {
      const q = encodeURIComponent(searchEl.value || '');
      const complete = completeOnlyEl.checked ? '1' : '0';
      const trigger = triggerOnlyEl.checked ? '1' : '0';
      const tf = encodeURIComponent(tfEl.value || '5m');
      const factor = encodeURIComponent(factorEl.value || 'smart');
      const limit = Math.max(1, Math.min(50000, Number(limitEl.value || 5000)));
      const t0 = performance.now();

      try {
        const res = await fetch(`/api/dashboard?q=${q}&complete=${complete}&trigger_only=${trigger}&tf=${tf}&factor=${factor}&limit=${limit}`);
        const data = await res.json();

        statCards(data);
        renderRows(data.rows || []);
        processVoiceFromRows(data.rows || [], data.config || {});
        processVoiceFromTrades();
        maybeBulletin(data.rows || []);

        const cfg = data.config || {};
        snapDayEl.textContent = `day:${data.snapshot_day || '-'} tf:${cfg.timeframe || '-'} factor:${cfg.factor || '-'}`;
        const tradeState = safe(data, ['status', 'trade', 'engine_state'], '-');
        metaEl.textContent = `shown:${data.displayed_rows} | source:${data.snapshot_rows} | trade:${tradeState} | load:${(performance.now()-t0).toFixed(0)}ms`;

        if (!voiceSupported()) updateVoiceStatus('voice:unsupported', false);
        else if (!voiceOnEl.checked) updateVoiceStatus('voice:off', false);
        else {
          const vn = voiceState.selectedVoice ? voiceState.selectedVoice.name : 'selecting';
          updateVoiceStatus(`voice:on ${vn} q:${voiceState.queue.length}`, true);
        }
      } catch (e) {
        metaEl.textContent = 'Error: ' + e.message;
      }
    }

    function restartLoop() {
      if (timer) clearInterval(timer);
      const ms = Math.max(500, Math.min(10000, Number(refreshMsEl.value || 2000)));
      refresh();
      timer = setInterval(refresh, ms);
    }

    function initVoices() {
      if (!voiceSupported()) {
        updateVoiceStatus('voice:unsupported', false);
        return;
      }
      pickVoice();
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = () => {
          pickVoice();
        };
      }
    }

    voiceOnEl.addEventListener('change', () => {
      if (!voiceOnEl.checked) {
        clearVoiceQueue();
        updateVoiceStatus('voice:off', false);
      } else {
        pickVoice();
        updateVoiceStatus('voice:on', true);
        pumpVoiceQueue();
      }
    });

    voicePresetEl.addEventListener('change', () => {
      pickVoice();
      const vn = voiceState.selectedVoice ? voiceState.selectedVoice.name : 'not-found';
      updateVoiceStatus(`voice:${vn}`, true);
      enqueueVoice('voice-preset-change', `Voice profile changed. Current voice ${vn}.`, 1, 1000);
    });

    voiceTestEl.addEventListener('click', () => {
      if (!voiceSupported()) {
        updateVoiceStatus('voice:unsupported', false);
        return;
      }
      pickVoice();
      const vn = voiceState.selectedVoice ? voiceState.selectedVoice.name : 'default';
      console.log('Testing voice:', vn);
      // Immediate test with priority 1
      enqueueVoice('manual:test', `Namaskar. Superalgo trading system active. Voice ready.`, 1, 1000);
    });
    
    exportCsvEl.addEventListener('click', exportTrades);

    applyEl.addEventListener('click', restartLoop);
    
    // Update IST time every second
    setInterval(() => {
      istTimeEl.textContent = formatISTTime();
      istDateEl.textContent = formatISTDate();
    }, 1000);
    
    // Initial time set
    istTimeEl.textContent = formatISTTime();
    istDateEl.textContent = formatISTDate();

    initVoices();
    restartLoop();
  </script>
</body>
</html>
